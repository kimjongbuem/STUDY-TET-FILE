큰주제: 데이터링크계층!

<1 데이터 링크 계층 프로토콜 했던 내용들 복습>

1) 점대점 방식
	직접연결구조임, 라우팅과정없고, 둘사이의 전송오류 감지, 복구기능	
2) 멀티드롭 
	호스트 주소 개념이 추가 필요함
	- 하나의 호스트가 다수의 호스트와 연결된 비대칭 형태임. - 하나의 물리 매체를 공유함. => 물리적인 전송오류 발생

그래서 이 물리적인 전송오류를 해결해야 하는데, 데이터링크계층이 이 역할을 해. => 재전송하는 식으로 해결함.

프레임의 종류
1) 정보프레임 : 상위계층이 전송을 요구한 데이터를 수신 호스트에 전송하는 용도로 사용함. 약칭하여 I 프레임이라고도 불림.
상위 계층에서 보낸 데이터와 함께 프레임의 순서번호(시퀀스넘버 => 중복 프레임제거^^), 송수신호스트 주소

2) 긍정응답 프레임 : 정상적 도착이면 나를 보내지!
=> ACK 프레임 ( 긍정응답프레임) 송신호스트가 이 프레임을 받으면 정상적으로 도착했구나! 라고 앎.

3) 부정응답 프레임: 야... 이 프레임 변형됐어.ㅠㅠ
=> NAK 프레임 ( 부정응답 프레임) 수신호스트가 송신호스트에게 다시 재전송 요청( 동일 순서번호로 재전송) 


가정1) 오류랑 흐름제어가 필요없는 프로토콜(무한 버퍼 + 전송오류없음)
	정보프레임만 전달해도 깔쌈 ㅇㅇ

가정2) 오류제어만 필요없는 프로토콜(버퍼 유한)
송신호스트의 데이터 전송 제어를 위해 정보프레임을 받은 수신호스트는 응답프레임을 보내줘야한다.(ACK) - 정지/대기

가정 3) 원래 이게 보통 네트워크 환경(유한버퍼 + 전송오류 존재)
단방향 통신에서 분실/변형이 일어날 수 있다. 만약 분실의 경우 무한정 기다리니 타임아웃기능을 추가하여 ACK/NCK가 일정시간 오지않으면 재전송을 한다.
 
가정 4) NAK가 없는경우
NAK가 없다면 타이머를 작동시켜야 함 왜냐하면 변형이 일어났는데 ACK는 안주며, NAK는 없어.. 그럼 보낼게 없으니. 시간다되면 그냥 부정적인거나 분실된걸로 임의로 판단하며 다시 재전송.

가정 4-2) NAK있는 경우
바로 재전송을 받을수 있음. 좋아! 근데 해당 오류 부분이 시퀀스넘버이고 그러면 좀 문제가 될 수 있음.


<2 슬라이딩 윈도우 프로토콜>
	단방향보다는 요즘 양방향이지!(두 호스트 간의 프레임 전송을 위한 일반적인 통신 프로토콜이다)

기본절차)
1. 송신프레임은 프레임의 순서 번호 오류검출코드, 프레임에 표기한 후 선서 번호에 따라 순차적 송신함.
2. 순서번호에 근거하여 수신호스트는 응답프레임을 회신한다 ㅇㅇ(중요) 그 회신하는 프레임에는 정상적으로 수신한 프레임을 주지않고 다음에 올 것을 기대한 프레임정보를 표기한다. => 여기까지 정상적이다라는 소리!
3. 송신호스트는 송신한 정보프레임을 내부 버퍼에 유지하며, 이를 송신윈도우라고 부름. 즉 송신윈도우에서 대기하는 프레임은 송신은 했으나 긍정 응답 프레임을 받지 못한 프레임이다.
4. 수신호스트는 수신한 정보 프레임을 보관하기 위한 버퍼가 있어야하는데 이를 수신윈도우라고 부름 
근데 프로토콜 동작방식에 내부 버퍼크기가 차이가 있음.
-고백 방식: 하나보내고 하나 기다리고 이런식이라서 크기가 1임 
- 선택적 재전송 방식: 프레임의 도착이 비순서적으로 이루어지기 때문에 수신윈도우 = 송신위도우 크기가 같아야함.(동일)

흐름제어)
슬라이딩 윈도우는 윈도우의 이동을 의미하며 이는 흐름제어의 기능을 상징적으로 대변함.
이말은 수신호스트가 수신할 수 있는 정보프레임의 개수를 윈도우 크기로 지정해서 송신호스트의 프레임 전송 속도를 제어함.

1.1 시퀀스 넘버
0~ 임의의 최대값으로 값이 정의되는데, 만약 최대값을 넘기게 되면 0부터 다시시작하니 유의가 필요하다(중복되기때문) 그렇기에 송신윈도우 크기보다 순서 번호의 최댓값이 커야한다는 전제가 있다.
N비트 할당시 순서번호의 범위는 (0~2^n-1) 기본값은 n = 1임. 

1.2 윈도우 크기
기본원리 : 송신호스트가 수신호스트의 긍정응답 프레임을 받지 않고도 전송할수 있는 정보의 최대개수, 윈도우 크기 규정 <=송신 윈도우에 보관된 프레임은 수신호스트에 전송했으나, 아직 긍정응답 프레임못받은 상태
윈도우에 포함되는 정보 프레임의 관리는 순서번호를 기반으로 이루어져서, 이들 순서번호의 묶음이 윈도우이다. ( 낮은번호 -> 점차 높은 번호로)
예시) 윈도우크기가 3이라면 일단 3개 프레임 보내고 하나의 긍정응답프레임을 받으면 송신에서 하나를 수신에게 보내는 형식. 물론 2개이상 긍정응답프레임 받으면 수신호스트에게도 프레임 2개를 보내줌.


연속형 전송)
정보프레임에 대해 긍정 응답 프레임을 받지 않고도 여러 정보 프레임을 연속으로 전송하는 기능.

//  ? 정지 / 대기 방식의 프로토콜이며, 송수신윈도우 크기가 1인 특수한경우야.
근데 물리적 거리차가 심해서 전송하는 시간이 오래 걸리면서 크기가 1이면 효율이 쓰레기야. 그래서..
ACK를 받지 않고 여러 정보 프레임을 전송할 수 있게하는게 **연속형전송임.

그럼 정보프레임 오류 발생하면 어쩔껀데?
이를 위한 해결 방안이 2개나!
1) 고백 n 방식 
일단 정보 프레임 다보내는데 정상적으로 보내진데 까지(해당 프레임 이하는 모두 정상이라는 뜻 해당 프레임만 정상전송이라는 뜻 아님)는 ACK 프레임 보내고 그다음 잘못된 부분은 NAK 프레임 보내는데 NAK보낸 프레임 이후 모두 재전송한다.
(비효율아님?) 왜냐면 잘못된 부분만 보내면 되는디, ㅠ <=> 재전송지연시는 효과적일수도?
=> NAK 프레임 받은 이후애들은 처리될때까지 그냥 버림(DISCARD) 1:1마크 => 수신윈도우 크기 1
2) 선택적 재전송 방식
아까도 말했지 오류부분만 재전송하면 되는데 다보내면 이상하다고...
이런 부분에서 해결을 위해 선택적 재전송 방식을 써라 
내경우는 1:1마크가 아닌 정상적으로 작동한 프레임을 모두 갖고 있기 때문에, 송수신윈도우 크기가 같아요.. 물론 도착순서와 송신 순서가 일치 안합니다.


피기 배깅) 이전까진 정보 주고 응답주고 하나씩이라서 효율 좀 쓰렉 
양방향 전송 기능을 갖춘 채널 방식은 송수신 호스트 구분없고 양방향으로 동시에 정보, 응답 프레임을 교차 전송가능함
즉 정보프레임을 재정의 해보면 정보프레임 + 응답프레임까지 전송해야함. 그렇기에 (정보, 응답) 이렇게 구성하면 효율을 높이는데 이를 피기배깅이라함. 
구성 : (자신이 전송하는 데이터의 순서번호, 제대로 수신한 프레임의 순서번호)
여러가지 생각해볼점 : 전송시점에 정보프레임이없거나 응답프레임이 없을 경우 + 이따가 응답프레임이 있으니 좀 기다릴 경우 어떻게 할것인지?=> 시스템 성능에 영향



<3 HDLC 프로토콜>
데이터링크프로토콜 SDLC -> HDLC -> LAP -> LAPB

HDLC프로토콜은 컴퓨터가 일대일 혹은 일대다 연결된 환경에서 , 주국, 종국, 혼합국 ,, 주국에서 보내는 메시지 : 명령 ,, 종국의 회신을 응답이라 함.

HDLC 프레임 구조 : 
01111110 ADDRESS(8) CONTROL(8) DATA>=0 CHECKSUM(16) 01111110

Address : 일대다로 연결된 환경에서 특정 호스트를 구분하여 지칭하는 목적으로 사용  
1. 주국에서 정보프레임을 전송할 때는 수신 호스트인 종국 주소를 표기함. 
2. 종국에서 전송할 때는 자기자신의 주소가 기록 
3. 일대일 환경에서는 명령과응답 구분 용도

Control : 프레임의 종류를 구분함. (정보, 감독 ,비번호프레임으로 3개 구분)
data : 가변크기의 전송 데이터가 포함됨, 상위계층인 네트워크 계층에서 보내진 패킷이 캡슐화
checksum : 오류 검출 용도 (코드)

정보 프레임
네트워크 계층의 데이터 전송을 위해 정의.
0 | seq(3) | p/f (1)| Next(3) 
seq : 정보 프레임의 송신용 순서 번호 정의
Next : 피기배깅을 이용한 응답 기능으로 사용하며 전에도 말했듯이 다음에 수신을 기대하는 프레임 번호임(이말은 이전까지의 프레임은 오류가 없다!)
P/F : 값이 1일 때 Poll or Final의 의미를 갖는다.  일반적으로 주국의 명령 프레임 : poll // 종국의 응답 프레임에선 Final
하나의 주국 컴퓨터가 다수의 종국 컴퓨터를 제어하는 용도이며, 주국이 종국에서 데이터 전송허가할때  사용함. ( 종국이 있는지 확인 1 = poll // 종국->주국 final의 의미로 사용

감독 프레임
정보 프레임에 대한 응답 기능을 수행함.
1 | 0 | type(2) | P/F (1)| Next(3) 
type 필드값에 따라 4가지로 구분된다.
type 0 : 00 RR 긍정응답 프레임(Receive Ready) 다음에 수신을 기대하는 프레임 번호를 next필드에 표기
type 1 : 01 REJ 부정응답 프레임(Reject) Next필드에는 재전송되어야 하는 프레임의 번호를 표기함. 근데 부정응답 프레임 받은 넘버 이후로 다전송해야함 => 고백방식
type 2 : 10 RNR 긍정응답프레임 + 흐름제어(Receive Not Ready) Next필드에는 다음에 수신할 프레임번호를 넣으나, 흐름제어기능을 추가하여 송신호스트의 송신을 중지하도록 요구. 다시 전송요구시 RR, REJ값있는 프레임전송
type 3 : 11 SREJ 선택적 재전송방식  (Selective Reject) 해당 Next필드의 순서번호를 갖는 특정프레임 재전송 요구

비번호 프레임**
순서번호가 없는 프레임
1 | 1 | type(2) | P/F | Modifier(3) 
type + modifier 필드를 합해 총 5비트로 다음과 같은 프레임들을 정의.

< 연결 설정 요구>
SABM : 비동기균형 모드 ( Asyncronous Balanced)
두개의 호스트가 동일한 능력을 가짐(혼합국) 명령/응답 양방향 -> 둘중 임의의 호스트가 연결설정 요구 함.

SNRM : 정규응답 모드( Normal Response )
종국이 데이터를 보내려면 반드시 주국의 허락을 받아야함.(상하 불균형모드)

SARM : 비동기 응답 모드(Asyncronous Response) 
불균형 모드이나 종국이 주국의 허락(p/f 비트 poll지정) 없이 데이터를 전송할 권한을 가짐.

<기타>
DISC : 연결 설정 해제 요구
RSET : 비정상적인 프로토콜의 동작에 따른 리셋 기능 수행(종국의 하드웨어 제어 기능 리셋)
FRMR : 비정상적인 프레임의 수신을 거부(프레임의 오류는 없으나 네트워크 상택 요상하면 사용)
UA : 비번호 프레임에 대한 긍정 응답 기능을 수행


LAP 프로토콜
비동기 응답 모드인 ARM으로 동작하는 프로토콜임.
1 ) 주국 ---SARM명령--> 종국 --UA--> 주국
2 ) 종국 ---SARM응답--> 주국 --SARM명령--> 종국 --UA-->주국  물론 DISC도 똑같음.

LAPB 프로토콜
Link Access Protocol-Balanced는 양쪽호스트가 혼합국이니 누구나 먼저 명령 전송가능!
SABM , UA 각각 한번씩 => 연결!




